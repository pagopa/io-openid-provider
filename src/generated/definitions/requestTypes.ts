// DO NOT EDIT THIS FILE
// This file has been generated by gen-api-models
// eslint-disable sonar/max-union-size
// eslint-disable sonarjs/no-identical-functions

import * as t from "io-ts";

import * as r from "@pagopa/ts-commons/lib/requests";

import { GetInfo } from "./GetInfo";

import { ProblemJson } from "./ProblemJson";

/****************************************************************
 * getInfo
 */

// Request type definition
export type GetInfoT = r.IGetApiRequestType<
  {},
  never,
  never,
  | r.IResponseType<200, GetInfo, never>
  | r.IResponseType<500, ProblemJson, never>
>;

export const getInfoDefaultResponses = {
  200: GetInfo,
  500: ProblemJson,
};

export type GetInfoResponsesT<
  A0 = GetInfo,
  C0 = GetInfo,
  A1 = ProblemJson,
  C1 = ProblemJson
> = {
  200: t.Type<A0, C0>;
  500: t.Type<A1, C1>;
};

export function getInfoDecoder<
  A0 = GetInfo,
  C0 = GetInfo,
  A1 = ProblemJson,
  C1 = ProblemJson
>(
  overrideTypes:
    | Partial<GetInfoResponsesT<A0, C0, A1, C1>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  r.IResponseType<200, A0, never> | r.IResponseType<500, A1, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...(getInfoDefaultResponses as unknown as GetInfoResponsesT<
      A0,
      C0,
      A1,
      C1
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes),
  };

  const d200 = (
    type[200].name === "undefined"
      ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
      : r.ioResponseDecoder<
          200,
          typeof type[200]["_A"],
          typeof type[200]["_O"],
          never
        >(200, type[200])
  ) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d500 = (
    type[500].name === "undefined"
      ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
      : r.ioResponseDecoder<
          500,
          typeof type[500]["_A"],
          typeof type[500]["_O"],
          never
        >(500, type[500])
  ) as r.ResponseDecoder<r.IResponseType<500, A1, never>>;

  return r.composeResponseDecoders(d200, d500);
}

// Decodes the success response with the type defined in the specs
export const getInfoDefaultDecoder = () => getInfoDecoder();
